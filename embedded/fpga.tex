\namedsection{FPGA}{Pasat}

\begin{figure}
	\centering
	\includegraphics[scale=0.7]{figures/test_bench_schematic.PNG}
	\caption{Cortex M0 test bench schematic} \label{fig:test_bench}
\end{figure}

Through ARM, we managed to gain access to a fixed configuration of the Cortex-M0 Processor known as Cortex-M0 DesignStart \cite{armdesignstart}. This simplified version offers us access to a Verilog version of the Cortex-M0 under the form of an obfuscated and preconfigured netlist, but it can be synthesized. This package offers us some Verilog codea test-bench which allow a simulation of the Cortex-M0 DesignStart module connected to a memory model and a clock and reset generator. It also include a basic C helloworld.c program. The schematic for the test-bench can be seen in figure \ref{fig:test_bench} and it connects the CORTEXM0DS to a memory model, a clock and a reset generators.

The tool used for simulating the test-bench is ModelSim, which is a tool that offers the possibility of simulating hardware description languages such as Verilog and VHDL. A new project must be created in ModelSim to which we add the Verilog files provided in the package, the test-bench and another binary file provided, ram.bin, which is an example memory image for the processor. The file is loaded at the beginning of the simulation by the test-bench.  The memory image is used for the helloworld.c program, which is used by the test-bench to write a message to the simulator's console and after that end the simulation. The result of the simulation can be seen in

Also, access was given to the CM0DS example design kit which contains various AHB-Lite peripherals and infrastructure components, useful to create complete systems. Before implementing the actual algorithm on the FPGA, a more basic simulation needs to be conducted on the platform to assure that it is compatible with the specific FPGA used. Next, the analysis of the sensors used for our project will be discussed. After that, discussions related to the about mBed platform which contains the Cortex M0+ and the Digilent Nexys4 FPGA board on which we aimed to implement the microprocessor as an extension will take place.


\subsection{Software development and simulation}
In this section, a software program that will verify the memory fetches of some predefined constants. The program used for this will be ARM Keil μVision, which is a IDE(Integrated Development Environment) which allows quick and easy building of projects and includes other facilities such as: make facilities, source code debug, program debug and complete simulations.

To start, a new project must be created in μVision. Next, the device must be selected device database so ARM-ARM Cortex M0 plus-ARMCM0P is selected which can be seen in figure \ref{fig:armcm0p} above.
\begin{figure}
\centering
\includegraphics[scale=0.7]{figures/armcm0p.PNG}
\caption{Selection of the Cortex M0+ for the μVision project} 
\label{fig:armcm0p}
\end{figure}

After this is selected, the options menu is accessed for this device. Next, the target options need to be accessed and the following modification need to be made:

- under Target section, the Read/Write Memory Areas, RAM1 starts at 0x0 and has the size of 0x400000 (this setting is used to create a linker scatter file. Another requirement for this is the having the Use Memory Layout from Target Dialog enabled in the Linker section);

- under Output section, the Debug Information and Browse Information sections need to be ticked(this defines the resulting output files from the tool chain and allows the user programs to be started after the building process is complete);

- under Listing section, all the default selected features stay the same(here all the listing files generated by the tool chain are specified);

- under User section, in Run\#1:"fromelf -cvf code.axf --vhx --32x1 -o code.hex" and Run\#2:"fromelf -cvf code.axf -o disasm.txt" in Run User Programs After Build/Rebuild those code lines are inserted in order to create a .axf file from the .hex file;

- under C/C++ section, the One ELF Section per Function is unticked and the Warnings are set to <unspecified> (here C/C++ specific tool options are set);

-under Asm section, all the settings are kept to default also( this allows the setting of specific Assembler tool options);

-under Linker section, the R/W Base entry is deleted and only the R/O Base: 0x00000000 remains(linker settings are required in order to configure the physical memory location of the target). The location of memory classes and sections is defined here.

-under Debug section, the default settings for µVision4 Debugger stay the same;

-under Utilities, the Use Target Driver for Flash Programming in the Configure Flash Menu Command is left checked.

\begin{lstlisting}[caption={Reset Handler},label={lst:reset-handler}]
Reset_Handler	PROC
		GLOBAL Reset_Handler
		ENTRY

AGAIN		LDR	R1, =0x50000000		;Write to LED with value 0x55
		LDR	R0, =0x55
		STR	R0, [R1]


		LDR	R0, =0x2FFFFF		;Delay
Loop		SUBS	R0,R0,#1
		BNE Loop

		LDR	R1, =0x50000000		;Write to LED with value 0xAA
		LDR	R0, =0x55
		STR	R0, [R1]

		LDR	R0, =0x2FFFFF		;Delay
Loop1		SUBS	R0,R0,#1
		BNE Loop1
\end{lstlisting}

After all of these steps have been done,it is now time to add assembly file provided by ARM, the cm0dasm.s to the source. Taking a look at the reset handler, which can be seen in \ref{lst:reset-handler}, it turns on half of the 8-bit LEDs( for example 0, 2, 4 ,6), sets up a counter and uses it for a short time delay, then turns on the other half and delays another period.

After the successful building, the code.hex should be created and converted into a .axf because it was set in the User section. The .axf file needs to be converted to a .bin in order to program the FPGA. The MDK/Keil offers a tool called "fromelf" which can do this conversion. It is called in the following way:

fromelf --bin --o code.bin code.axf

This can be used to program the FPGA. Now, the implementation of the Cortex-M0+ will be discussed.

\subsection{System Implementation}

ARM offers access to packs that makes the implementation of the Cortex M0 on the FPGA is discussed. The components which will be used are: the ARM Cortex-M0 processor, the AHB-Lite system bus and two AHB peripherals: the program memory(which will be implemented using on-chip memory blocks) and a simple LED peripheral. Some of the steps are similar for implementing the Cortex M0 on a older FPGA, but since different modules and softwares are required, it is not a fully followable guide.
\note{Add implementation reference} 

The software used for this implementation is Vivado Design Suite. This software is produced by Xilinx and is used for synthesis and analysis of HDL designs and is a improved version of the Xilinx ISE which also allows features such as system on a chip development and a high-level synthesis. A new project must be created.

The ARM DesignStart  package which contains the logic of the ARM Cortex-M0 processor written in Verilog and can be synthesized and implemented on a FPGA platform. The Cortex-M0 DesignStart will be used, which is a simplified version of the industry Cortex-M0 processor, but has some features reduced which are not essential for this project such as in the number of interrupts(from 32 to 16). Two verilog files are included in this pack:  cortexm0ds\_logic.v and CORTEM0DS.v. The cortexm0ds\_logic.v contains the Cortex-M0 DesignStart processor logic level Verilog file, while the CORTEXM0DS.v includes the Cortex-M0 DesignStart processor macro cell level.

The software code needs to be compiled to machine code in order to program the processor. The program memory is the phyiscal memory used to store the instructions to which need to be executed by the processor. On-chip memory block are used in order to implement the program memory in SoC, for example the Block RAM(BRAM) which is present on this FPGA. The program image needs to be merged into the hardware design during synthesis to load the program on the on-chip memory of the FPGA.

Now, in order to implement the Cortex M0+ on the FPGA, more then just the ARM DesignStart Verilog codes are necessary. The ARM Cortex-M System Design Kit (CMSDK) contains a set of AMBA AHB and APB components and examples for various Cortex-M systems processors, including the Cortex-M0. The  Verilog file  used from this package in order to reproduce the desired experiment will be discussed.

The AHBDCD.v contains the code for the address decoder of the AHB bus. This uses a Multi-layer bus architecture having only one AHB master on each of the input layers and one AHB slave on each of the outputs, the entire system address decoding can be done within the decoder section. It selects one of the slaves depending on where the address bus currently is and also is.

The AHBMUX.v contains the code for the slave multiplexor of the AHB bus. This uses parameters in order to specify the slave port usage in order for the synthesis process to no generate extra logic which is not necessary for the project. The slave to master multiplexer controls the response signals and read data routing from the bus slaves to the bus masters. The address decoder presented earlier is used to determine the currently selected slave and generates the HSEL signal to the AHB slaves and slave multiplexer. The multiplexer creates the connection between the slave outputs and the inputs of the bus masters. 

\begin{figure}
\centering
\includegraphics[scale=0.7]{figures/decoder_and_multiplexer.PNG}
\caption{Address Decoder and Slave Multiplexor } 
\label{fig:decoder_multiplexer}
\end{figure}
In figure \ref{fig:decoder_multiplexer} how two Address Decoder and Slave Multiplexor can bee seen. The HADRR[0:31] signal, sends the read data from multiplexer to master \cite{ahblite}. The HREADY signal goes from the multiplexor to the master and slaves and when it is set to HIGH, it indicates that the previous transfer has been completed. The HRESP signal transfers the response signal from multiplexor to master. Each of the slaves has its own select signal HSEL which indicates the current transfer intended for that specific slave. Before being able to respond to the current transfer, the status of HREADY must be known in order to ensure that the previous transfer has been completed. 

The AHB2BRAM.v contains the on-chip memory peripheral (BRAM) 
which is a configurable memory module that gives access to a variety of BRAM Interface Controllers. This is used for the program memory of the processor.

The AHB2LED.v contained the LED peripheral module. Selected LED will light up when a specific generated patters will be detected and will turn off when another pattern is detected.

The AHBLITE\_SYS.v contains the top-level module. The AHB-Lite is a subset of the full AHB specification which is used in designs where there is no more than one bus master used. This simplifies the AHB specification because it removes the unnecessary protocol used for more bus masters.

The ARMSOC\_s6.ucf file is the user constraint file which creates the connection between the assigned nets and FPGA pins.

All of these files files need to be added to a Vivado project in order to create and download the bitstream file to the FPGA. A new project called CM0DS\_System is created, specifying that it is RTL project. A mixed implementation setting between Verilog/VHDL will be required for this project. The processor is described in Verilog while the additional modules are in VHDL. Next, in the list of Xilinx parts, the XC7A100T-1CSG324C needs to be selected because this is the part name for the Nexys4 board. 
\begin{figure}
\centering
\includegraphics[scale=0.7]{figures/AHBLITE_SYS_modules_ISE_schematic.PNG}
\caption{AHB Lite top-module } 
\label{fig:ahblite_sys}
\end{figure}

After the project is created, the AHBALITE\_SYS.v is set as a top module since this creates the connection between all the components. This can be seen in \ref{fig:ahblite_sys} above. Because this is a Nexys4 board and the Clock Divider supplied in the package are not compatible due to the fact that it requires a Spartan 6 Series processor, a new IP needed to be created for this specific FPGA. In order to add this we need to go to Source-> New Source-> IP CORE(Generator and Architecture Wizard)-> Clocking-> Clocking Wizard. This is going to generate a system clock at 10MHz from the board's 50MHz external oscillator. In figure \ref{fig:clock}, the Input Clock Frequency is set 50 MHz and the Output Frequency to 10 MHz and it is named "uClockDiv".

\begin{figure}
\centering
\includegraphics[scale=0.7]{figures/clock_creation.PNG}
\caption{Clocking Wizard settings } 
\label{fig:clock}
\end{figure}

Since the user constraint file supplied is meant to be used to a Spartan 6 Series FPGA board, the user constraint file needed modifications in order to fit the Artix-7 FPGA. The UCF can be seen in appendix. After this, the top module of the simulation can be implemented and translated int o a .bit file which is used to program the FPGA.

\subsection{Functional Simulation}
Due to some unplanned delays in acquiring certain documentations, delays in obtaining licenses for the various software used and difficulties encountered during the creation of a proper .bit file, a functional simulation was not properly conducted..A basic simulation of the Cortex M0 was presented in \ref{sec:cortex}.  The functional simulation of the system verifies if the signal in HRDATA are the ones expected and if it works as expected. Vivado Hardware Debug is the Vivado tool used for debugging. This is accessed by going to Design->View:Simulation. If a complete functional would have been performed, a run-time simulation needs to also be performed. On-chip debugging tools such as ChipScope are required in order to perform this sort of simulation. Inside the analysis, these AHB signals need to be evaluated to see if they work correspondingly: 
HADDR[31:0] 
HWDATA[31:0]
HRDATA[31:0]
HWRITE
HREADY
HSIZE[2:0]
HTRANS[1:0]
HRESP

\subsection{Conclusion}
The team decided that the mBed platform had a better progress and would be more suitable for our final design since it's small size will allow strapping it people, opposed to the FPGA board which was much greater in size. Because of this, I stopped attempting to implement the Cortex M0 and redirected my attention to other aspects of the project where is was more necessary. Next, the successful section prototype of our project which was implemented on the mBed will be discussed.
